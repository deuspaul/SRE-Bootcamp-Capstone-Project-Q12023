name: build
on: 
  workflow_dispatch:
  push:
    branches:
      - 'feature/**'

jobs:
  build-job:
    permissions:
      checks: write
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ github.workspace }}/python
    steps:
      - name: checkout
        uses: actions/checkout@v3

      - name: testing
        shell: bash
        run: echo Hello World!

      - name: set up python
        uses: actions/setup-python@v3
        with:
          python-version: "3.10"

      - name: install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: lint with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          #flake8 . --count --select=E9 --show-source --statistics
          # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
          #flake8 . --count --max-complexity=10 --max-line-length=127 --statistics
          flake8 . --count --max-complexity=14 --max-line-length=185 --statistics
          

      - name: test with pytest
        id: pytest
        run: |
          test_results="test-results.xml"
          pytest --junit-xml "${test_results}"

          # Generate output
          echo "report_paths=${test_results}" | tee -a $GITHUB_OUTPUT
        env:
          PYTHONPATH: ${{ github.workspace }}/python

      - name: publish test report
        uses: mikepenz/action-junit-report@v3
        if: success() || failure()
        with:
          report_paths: ${{ steps.pytest.outputs.report_paths }}
          detailed_summary: true
          include_passed: true

      - name: generate coverage
        id: coverage
        run: |
          pytest --cov "." --cov-report=xml

          # expose coverage path
          path=$(realpath --relative-to=${{ github.workspace }} coverage.xml)
          echo "path=${path}" | tee -a $GITHUB_OUTPUT
          cat $GITHUB_OUTPUT
        env:
          PYTHONPATH: ${{ github.workspace }}/python

      - name: Publish Coverage
        uses: 5monkeys/cobertura-action@master
        with:
          path: ${{ steps.coverage.outputs.path }}
          minimum_coverage: 30
          fail_below_threshold: true
          show_line: true
          show_branch: true

      # - name: Check Dirty Repository
      #   run: |
      #     if ! git diff-index --quiet HEAD; then
      #       echo "::error::Dirty repository found"
      #       git status --porcelain
      #       exit 1
      #     fi

  build-container: #Ideally build container image with commit ID as the tag. Deploy it to a test ECR and check the endpoints.
    runs-on: ubuntu-latest
    needs:
      - build-job
    steps:
      - name: checkout
        uses: actions/checkout@v3

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          filte: ./Dockerfile
          push: false #just testing for now
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/academy-sre-bootcamp-paul-furlan:latest


# Next build the dev environment with terraform, deploy and test the recently created image.
  terraform-dev-env:
    uses: ./.github/workflows/terraform-dev.yml


  deploy-dev:
    runs-on: ubuntu-latest
    needs:
      - build-container
      - terraform-dev-env
    steps:
      - name: checkout
        uses: actions/checkout@v3
      
      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@13d241b293754004c80624b5567555c4a39ffbe3
      #   with:
      #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     aws-region: ${{ env.AWS_REGION }}

      # - name: Login to Amazon ECR
      #   id: login-ecr
      #   uses: aws-actions/amazon-ecr-login@aaf69d68aa3fb14c1d5a6be9ac61fe15b48453a2

      # - name: Build, tag, and push image to Amazon ECR
      #   id: build-image
      #   env:
      #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #     IMAGE_TAG: ${{ github.sha }}
      #   run: |
      #     # Build a docker container and
      #     # push it to ECR so that it can
      #     # be deployed to ECS.
      #     docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
      #     docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      #     echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # - name: Fill in the new image ID in the Amazon ECS task definition
      #   id: task-def
      #   uses: aws-actions/amazon-ecs-render-task-definition@97587c9d45a4930bf0e3da8dd2feb2a463cf4a3a
      #   with:
      #     task-definition: ${{ env.ECS_TASK_DEFINITION }}
      #     container-name: ${{ env.CONTAINER_NAME }}
      #     image: ${{ steps.build-image.outputs.image }}

      # - name: Deploy Amazon ECS task definition
      #   uses: aws-actions/amazon-ecs-deploy-task-definition@de0132cf8cdedb79975c6d42b77eb7ea193cf28e
      #   with:
      #     task-definition: ${{ steps.task-def.outputs.task-definition }}
      #     service: ${{ env.ECS_SERVICE }}
      #     cluster: ${{ env.ECS_CLUSTER }}
      #     wait-for-service-stability: true

# if endpoints fail delete image

# in the merge to main, tag the image as latest